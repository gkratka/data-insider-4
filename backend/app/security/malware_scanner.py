"""
Malware scanning service for uploaded files
"""
import os
import subprocess
import logging
from typing import Dict, Any, Optional
from pathlib import Path

logger = logging.getLogger(__name__)


class MalwareScanner:
    """ClamAV-based malware scanner for uploaded files"""
    
    def __init__(self):
        self.clamav_available = self._check_clamav_availability()
        
    def _check_clamav_availability(self) -> bool:
        """Check if ClamAV is available on the system"""
        try:
            result = subprocess.run(
                ["clamscan", "--version"], 
                capture_output=True, 
                text=True, 
                timeout=10
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            logger.warning("ClamAV not available. File scanning will use basic checks only.")
            return False
    
    def scan_file(self, file_path: str) -> Dict[str, Any]:
        """
        Scan a file for malware
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            Dictionary with scan results
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File not found: {file_path}")
            
        result = {
            "file_path": file_path,
            "is_clean": False,
            "threats_found": [],
            "scan_method": "basic",
            "scan_time": None,
            "file_size": os.path.getsize(file_path)
        }
        
        try:
            # Basic file checks first
            if not self._basic_file_checks(file_path):
                result["threats_found"].append("Suspicious file characteristics")
                return result
                
            # ClamAV scan if available
            if self.clamav_available:
                clamav_result = self._scan_with_clamav(file_path)
                result.update(clamav_result)
            else:
                # Fallback to basic checks
                result.update(self._basic_malware_checks(file_path))
                
        except Exception as e:
            logger.error(f"Error scanning file {file_path}: {e}")
            result["error"] = str(e)
            
        return result
    
    def _basic_file_checks(self, file_path: str) -> bool:
        """Basic file safety checks"""
        file_size = os.path.getsize(file_path)
        
        # Check file size (reject files over 500MB)
        if file_size > 500 * 1024 * 1024:
            return False
            
        # Check for suspicious file patterns
        with open(file_path, 'rb') as f:
            chunk = f.read(1024)  # Read first 1KB
            
            # Check for common malware signatures
            suspicious_patterns = [
                b'<script',  # JavaScript
                b'eval(',     # Code execution
                b'exec(',     # Code execution
                b'shell_exec', # Shell execution
                b'system(',   # System calls
                b'base64_decode', # Encoded content
                b'<?php',     # PHP code
            ]
            
            for pattern in suspicious_patterns:
                if pattern in chunk.lower():
                    return False
                    
        return True
    
    def _scan_with_clamav(self, file_path: str) -> Dict[str, Any]:
        """Scan file with ClamAV"""
        import time
        start_time = time.time()
        
        try:
            result = subprocess.run(
                ["clamscan", "--no-summary", file_path],
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            scan_time = time.time() - start_time
            
            if result.returncode == 0:
                # No threats found
                return {
                    "is_clean": True,
                    "scan_method": "clamav",
                    "scan_time": scan_time,
                    "threats_found": []
                }
            elif result.returncode == 1:
                # Threats found
                threats = self._parse_clamav_output(result.stdout)
                return {
                    "is_clean": False,
                    "scan_method": "clamav",
                    "scan_time": scan_time,
                    "threats_found": threats
                }
            else:
                # Scan error
                logger.error(f"ClamAV scan error: {result.stderr}")
                return self._basic_malware_checks(file_path)
                
        except subprocess.TimeoutExpired:
            logger.error(f"ClamAV scan timeout for {file_path}")
            return {
                "is_clean": False,
                "scan_method": "timeout",
                "threats_found": ["Scan timeout - file may be too large or corrupted"]
            }
    
    def _basic_malware_checks(self, file_path: str) -> Dict[str, Any]:
        """Basic malware detection without ClamAV"""
        threats = []
        
        # Check file extension against known dangerous extensions
        dangerous_extensions = {
            '.exe', '.com', '.bat', '.cmd', '.scr', '.pif', '.vbs',
            '.js', '.jar', '.app', '.deb', '.pkg', '.dmg'
        }
        
        file_ext = Path(file_path).suffix.lower()
        if file_ext in dangerous_extensions:
            threats.append(f"Dangerous file extension: {file_ext}")
            
        # Check MIME type consistency
        try:
            import magic
            mime_type = magic.from_file(file_path, mime=True)
            
            # Check for MIME type spoofing
            expected_types = {
                '.csv': 'text/csv',
                '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                '.xls': 'application/vnd.ms-excel',
                '.json': 'application/json',
                '.parquet': 'application/octet-stream'
            }
            
            if file_ext in expected_types and mime_type != expected_types[file_ext]:
                # Allow some flexibility for CSV files
                if not (file_ext == '.csv' and mime_type in ['text/plain', 'text/csv']):
                    threats.append(f"MIME type mismatch: expected {expected_types[file_ext]}, got {mime_type}")
                    
        except ImportError:
            logger.warning("python-magic not available, skipping MIME type checks")
        except Exception as e:
            logger.error(f"Error checking MIME type: {e}")
            
        return {
            "is_clean": len(threats) == 0,
            "scan_method": "basic",
            "threats_found": threats
        }
    
    def _parse_clamav_output(self, output: str) -> list:
        """Parse ClamAV output to extract threat names"""
        threats = []
        lines = output.strip().split('\n')
        
        for line in lines:
            if "FOUND" in line:
                # Extract threat name from line like "file.exe: Trojan.GenKryptik.1234 FOUND"
                parts = line.split(':')
                if len(parts) >= 2:
                    threat_info = parts[1].strip().replace(' FOUND', '')
                    threats.append(threat_info)
                    
        return threats
    
    def quarantine_file(self, file_path: str, quarantine_dir: str = None) -> str:
        """Move infected file to quarantine directory"""
        if not quarantine_dir:
            quarantine_dir = "/tmp/quarantine"
            
        os.makedirs(quarantine_dir, exist_ok=True)
        
        file_name = os.path.basename(file_path)
        quarantine_path = os.path.join(quarantine_dir, f"quarantined_{file_name}")
        
        # Move file to quarantine
        import shutil
        shutil.move(file_path, quarantine_path)
        
        logger.warning(f"File quarantined: {file_path} -> {quarantine_path}")
        return quarantine_path
    
    def get_scanner_status(self) -> Dict[str, Any]:
        """Get current scanner status and capabilities"""
        return {
            "clamav_available": self.clamav_available,
            "scanner_version": self._get_clamav_version() if self.clamav_available else None,
            "last_db_update": self._get_last_db_update() if self.clamav_available else None,
            "supported_methods": ["basic", "clamav"] if self.clamav_available else ["basic"]
        }
    
    def _get_clamav_version(self) -> Optional[str]:
        """Get ClamAV version"""
        try:
            result = subprocess.run(
                ["clamscan", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.stdout.strip() if result.returncode == 0 else None
        except:
            return None
    
    def _get_last_db_update(self) -> Optional[str]:
        """Get last database update time"""
        try:
            # Check freshclam log or database timestamp
            db_path = "/var/lib/clamav/daily.cvd"
            if os.path.exists(db_path):
                import datetime
                timestamp = os.path.getmtime(db_path)
                return datetime.datetime.fromtimestamp(timestamp).isoformat()
        except:
            pass
        return None


# Global scanner instance
scanner = MalwareScanner()